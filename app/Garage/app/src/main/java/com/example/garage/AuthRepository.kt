package com.example.garage

import android.content.Context
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response

/**
 * Repository responsible for handling user authentication and session management.
 * Utilizes Retrofit for API calls and Room for local token storage.
 *
 * @param context Android context used for accessing SharedPreferences and Room database.
 */
class AuthRepository(private val context: Context) {

    // Instance of the local token database (Room)
    private val database = TokenDatabase.getInstance(context)

    // Instance of the API interface generated by Retrofit
    private val api = RetrofitInstance.api

    /**
     * Logs in the user by making an API call with the provided email and password.
     * On success, stores the access token and invokes the success callback.
     * On failure, invokes the error callback with an appropriate message.
     *
     * @param email User's email.
     * @param password User's password.
     * @param onSuccess Callback invoked when login is successful.
     * @param onError Callback invoked when login fails, with an error message.
     */
    fun login(email: String, password: String, onSuccess: () -> Unit, onError: (String) -> Unit) {
        val request = LoginRequest(email, password)
        api.login(request).enqueue(object : Callback<LoginResponse> {
            override fun onResponse(call: Call<LoginResponse>, response: Response<LoginResponse>) {
                if (response.isSuccessful) {
                    val token = response.body()?.access_token ?: return
                    saveToken(token)
                    onSuccess()
                } else {
                    onError("Invalid email or password")
                }
            }

            override fun onFailure(call: Call<LoginResponse>, t: Throwable) {
                onError("Network error: ${t.message}")
            }
        })
    }

    /**
     * Registers a new user by sending their details to the API.
     * On success, invokes the success callback.
     * On failure, invokes the error callback with an appropriate message.
     *
     * @param username New user's username.
     * @param email New user's email.
     * @param password New user's password.
     * @param onSuccess Callback invoked when registration is successful.
     * @param onError Callback invoked when registration fails, with an error message.
     */
    fun register(username: String, email: String, password: String, onSuccess: () -> Unit, onError: (String) -> Unit) {
        val request = RegisterRequest(username, email, password)
        api.register(request).enqueue(object : Callback<Void> {
            override fun onResponse(call: Call<Void>, response: Response<Void>) {
                if (response.isSuccessful) {
                    onSuccess() // Registration successful
                } else {
                    onError("Registration failed: ${response.message()}")
                }
            }

            override fun onFailure(call: Call<Void>, t: Throwable) {
                onError("Network error: ${t.message}")
            }
        })
    }

    /**
     * Saves the access token into the local database (Room) asynchronously.
     *
     * @param token Access token to be saved.
     */
    private fun saveToken(token: String) {
        CoroutineScope(Dispatchers.IO).launch {
            val authToken = AuthToken(token = token)
            database.tokenDao().insertToken(authToken)
        }
    }

    /**
     * Retrieves the stored access token from the local database (Room).
     *
     * @return Access token if available, or null if no token is stored.
     */
    suspend fun getToken(): String? {
        return database.tokenDao().getToken()?.token
    }

    /**
     * Clears the user's session by removing the access token from both SharedPreferences
     * and the Room database.
     */
    fun clearSession() {
        // Clear SharedPreferences
        val sharedPreferences = context.getSharedPreferences("user_prefs", Context.MODE_PRIVATE)
        sharedPreferences.edit().clear().apply()

        // Clear Room database tokens
        CoroutineScope(Dispatchers.IO).launch {
            database.tokenDao().deleteAllTokens()
        }
    }
}